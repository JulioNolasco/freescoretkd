#! /usr/bin/perl

use lib qw( /usr/local/freescore/lib );
use Mojolicious::Lite;
use Try::Tiny;
use FreeScore;
use FreeScore::Forms::WorldClass;
use FreeScore::Forms::WorldClass::RequestManager;
use JSON::XS;
use Digest::SHA1 qw( sha1_hex );
use List::MoreUtils (qw( firstidx ));
use Data::Dumper;
use Data::Structure::Util qw( unbless );
use EV;

our $json    = new JSON::XS();
our $client  = {};
our $watcher = {};

# ============================================================
# JUDGE INTERFACE
# ============================================================

# ------------------------------------------------------------
# GET THE DIVISION STATUS
# ------------------------------------------------------------
get '/:tournament/:ring/status' => sub { 
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring' );
	my $progress   = new FreeScore::Forms::WorldClass( $tournament, $ring );
	my $division   = $progress->current();

	try {
		send_response( $self, { 'description' => "Division $division->{ name } status", 'division' => $division->{ name }, 'current' => $division->{ current }, 'form' => $division->{ form }, 'round' => $division->{ round }, 'judges' => $division->{ judges }, 'forms' => $division->{ forms }{ $division->{ round }}, 'autopilot' => $division->autopilot() } );

	} catch {
		send_response( $self, { error => $_ });
	}
};

# ------------------------------------------------------------
# GET THE NUMBER OF JUDGES FOR THIS DIVISION
# ------------------------------------------------------------
get '/:tournament/:ring/judges' => sub { 
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring' );
	my $progress   = new FreeScore::Forms::WorldClass( $tournament, $ring );
	my $division   = $progress->current();

	try {
		send_response( $self, { 'description' => 'Number of Judges', 'division' => $division->{ name }, 'judges' => $division->{ judges } } );

	} catch {
		send_response( $self, { error => $_ });
	}
};

# ------------------------------------------------------------
# TURN ON AUTOPILOT FOR THIS RING
# ------------------------------------------------------------
get '/:tournament/:ring/:judge/autopilot' => sub { 
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring' );
	my $judge      = $self->param( 'judge' );
	my $progress   = new FreeScore::Forms::WorldClass( $tournament, $ring );
	my $division   = $progress->current();

	my $response   = autopilot( $division, $judge );
	send_response( $self, $response );
};

# ============================================================
# COORDINATOR INTERFACE
# ============================================================

# ------------------------------------------------------------
# COORDINATOR REQUESTS CHANGES FOR ATHLETE ORDER OR NAME(S)
# ------------------------------------------------------------
post '/:tournament/:ring/coordinator' => sub {
	my $self         = shift;
	my $tournament   = $self->param( 'tournament'     );
	my $ring         = $self->param( 'ring'           );

	try {
		my $content      = $json->decode( $self->req->body );
		my $progress     = new FreeScore::Forms::WorldClass( $tournament, $ring );
		my $division     = $progress->find( $content->{ divid } );
		die "Division $content->{ divid } not found" unless defined $division;
		$division->edit_athletes( $content->{ athletes }, $content->{ round } );
		$division->write();
		send_response( $self, { description => "Saving coordinator change request to athlete ordering and/or name(s)", round => $division->{ round }, athletes => $content->{ athletes } });
	} catch {
		send_response( $self, { error => $_ });
	}
};

# ------------------------------------------------------------
# MANAGE RINGS, DIVISIONS, AND ATHLETES VIA WEBSOCKETS
# ------------------------------------------------------------
websocket '/worldclass/:tournament/:ring' => sub {
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring'       );
	my $manager    = new FreeScore::Forms::WorldClass::RequestManager( $tournament, $ring, $self->tx() );
	my $progress   = undef;
	my $staging    = undef;
	my $id         = sprintf "%s", sha1_hex( $self->tx() );
	my $group      = sprintf "%s-ring-%d", $tournament, $ring;

	$self->inactivity_timeout( 3600 ); # 1 hour
	$manager->{ _autopilot } = \&autopilot;

	# ===== REGISTER THE CLIENT
	my $c = $client->{ $group }{ $id } = { id => $id, device => $self->tx() }; 
	print STDERR "WORLDCLASS $tournament ring $ring\n";
	print STDERR "  $_\n" foreach sort keys %{$client->{ $group }};
	print STDERR "\n";

	# ----------------------------------------
	# Handle messages
	# ----------------------------------------
	$self->on( message => sub {
		my $self    = shift;
		my $request = $json->decode( shift );
		my $judge   = exists $request->{ judge } && int( $request->{ judge } ) >= 0 ? $request->{ judge } : undef;

		$request->{ tournament } = $tournament;
		$request->{ ring }       = $ring;

		print STDERR $json->canonical->encode( $request ), "\n\n";

		# ===== READ PROGRESS
		try   { 
			$progress = new FreeScore::Forms::WorldClass( $tournament, $ring ); 
			if( $request->{ type } eq 'ring' ) {
				$staging = new FreeScore::Forms::WorldClass( $tournament, 'staging' );
				push @{$progress->{ divisions }}, @{$staging->{ divisions }};
			}
		} catch { $c->{ device }->send( { json => { error => "Error reading database '$tournament', ring $ring: $_" }}); };

		# ===== IDENTIFY WHICH CLIENTS ARE JUDGES
		$c->{ judge } = $judge if defined $judge;
		print STDERR "JUDGE $judge: " if defined $judge;

		# ===== WATCH FILESYSTEM FOR CHANGES
		$manager->watch_files( $judge );

		# ===== HANDLE REQUEST
		my $clients = $client->{ $group };
		try   { $manager->handle( $request, $progress, $clients ); }
		catch { $c->{ device }->send( { json => { error => "Error while processing request: $_\n", request => $request }}); };
	});

	# ----------------------------------------
	# Handle disconnects
	# ----------------------------------------
	$self->on( finish => sub { delete $client->{ $group }{ $id }; });
};

# ============================================================
# ERROR TRAPPING
# ============================================================
any '*command' => sub {
	my $self = shift;
	my $command = $self->param( 'command' );
	send_response( $self, { error => "Worldclass Service Error: Unknown command: $command" });
};

# ============================================================
# HELPER FUNCTIONS
# ============================================================

# ============================================================
sub autopilot {
# ============================================================
	my $division = shift;
	my $judge    = shift;

	# ===== DISALLOW REDUNDANT AUTOPILOT REQUESTS
	if( my $locked = $division->autopilot() ) {
		return { warning => 'Autopilot is already engaged for this ring by ' . ($locked == 1 ? 'Referee' : 'Judge ' . ($locked - 1)) . '.' };
	}

	# ===== ENGAGE AUTOPILOT
	try {
		$division->autopilot( $judge + 1 );
		$division->write();
	} catch {
		return { error => $_ };
	};

	my $delay = { leaderboard => 9, next => 6, total => 0 };
	my $round = $division->{ round };
	my $order = $division->{ order }{ $round };
	my $forms = $division->{ forms }{ $round };
	my $j     = firstidx { $_ == $division->{ current } } @$order;

	my $last = {
		athlete => ($division->{ current } == $order->[ -1 ]),
		form    => ($division->{ form }    == int( @$forms ) - 1),
		round   => ($division->{ round } eq 'finals' || $division->{ round } eq 'ro2'),
		each2   => (!($j % 2)),
	};

	# ===== AUTOPILOT ACTIONS
	my $action = { show => {}, go => {} };
	# ----------------------------------------
	$action->{ show }{ leaderboard } = sub {
	# ----------------------------------------
		return unless $division->autopilot(); # Cancel request if autopilot is disengaged
		if( $last->{ form } && ( $last->{ each2 } || $last->{ athlete } )) { 
			$division->display() unless $division->is_display(); 
			$division->write(); 
			Mojo::IOLoop->timer( $delay->{ next } => $action->{ go }{ next } );
			$delay->{ total } += $delay->{ next };

		} else {
			$action->{ go }{ next }();
		}
	};
	# ----------------------------------------
	$action->{ go }{ next } = sub {
	# ----------------------------------------
		return unless $division->autopilot(); # Cancel request if autopilot is disengaged
		my $go_next = {
			round   => $last->{ form } &&   $last->{ athlete } && ! $last->{ round },
			athlete => $last->{ form } && ! $last->{ athlete },
			form    => ! $last->{ form }
		};

		if    ( $go_next->{ round }   ) { $division->next_round(); }
		elsif ( $go_next->{ athlete } ) { $division->next_available_athlete(); }
		elsif ( $go_next->{ form }    ) { $division->next_form(); }
		$division->autopilot( 'clear' ); # Disengage autopilot
		$division->write();
	};

	# ===== AUTOPILOT BEHAVIOR
	# Autopilot behavior comprises the two afforementioned actions in
	# serial, with delays between.
	try {
		$delay->{ total } += $delay->{ leaderboard };
		Mojo::IOLoop->timer( $delay->{ leaderboard } => $action->{ show }{ leaderboard } );
		return { description => 'Autopilot is engaged', delay => $delay->{ total } };
	} catch {
		return { error => $_ };
	};
};

# ============================================================
sub send_response {
# ============================================================
	my $self = shift;
	my $data = shift;
	$self->res->headers->header( 'Access-Control-Allow-Origin' => 'http://freescore.net' );
	$self->render( json => $data );
};

# ============================================================
# HYPNOTOAD SERVER
# ============================================================
mkdir '/var/log/freescore' unless -e '/var/log/freescore';
app->config( hypnotoad => { listen => [ 'http://*:3088' ], pid_file => '/var/run/worldclass.pid', workers => 1 });
app->log( new Mojo::Log( path => '/var/log/freescore/worldclass.log', level => 'debug' ));
app->start();

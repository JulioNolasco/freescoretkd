#! /usr/bin/perl

use lib qw( /usr/local/freescore/lib );
use Mojolicious::Lite;
use Try::Tiny;
use FreeScore;
use FreeScore::Forms::WorldClass;
use FreeScore::Forms::WorldClass::RequestManager;
use JSON::XS;
use Digest::SHA1 qw( sha1_hex );
use List::MoreUtils (qw( first_index ));
use Data::Dumper;
use Data::Structure::Util qw( unbless );
use EV;

our $json    = new JSON::XS();
our $client  = {};
our $watcher = {};

# ------------------------------------------------------------
# MANAGE RINGS, DIVISIONS, AND ATHLETES VIA WEBSOCKETS
# ------------------------------------------------------------
websocket '/worldclass/:tournament/:ring' => sub {
	my $self       = shift;
	my $tournament = $self->param( 'tournament' );
	my $ring       = $self->param( 'ring'       );
	my $manager    = new FreeScore::Forms::WorldClass::RequestManager( $tournament, $ring, $self->tx(), \&autopilot );
	my $progress   = undef;
	my $staging    = undef;
	my $id         = sprintf "%s", sha1_hex( $self->tx() );
	my $group      = sprintf "%s-ring-%d", $tournament, $ring;

	$self->inactivity_timeout( 3600 ); # 1 hour
	$manager->{ _autopilot } = \&autopilot;

	# ===== REGISTER THE CLIENT
	my $c = $client->{ $group }{ $id } = { id => $id, device => $self->tx() }; 
	print STDERR "WORLDCLASS $tournament ring $ring\n";
	print STDERR "  $_\n" foreach sort keys %{$client->{ $group }};
	print STDERR "\n";

	# ----------------------------------------
	# Handle messages
	# ----------------------------------------
	$self->on( message => sub {
		my $self    = shift;
		my $request = $json->decode( shift );
		my $judge   = exists $request->{ judge } && int( $request->{ judge } ) >= 0 ? $request->{ judge } : undef;

		$request->{ tournament } = $tournament;
		$request->{ ring }       = $ring;

		print STDERR $json->canonical->encode( $request ), "\n\n";

		# ===== READ PROGRESS
		try   { 
			$progress = new FreeScore::Forms::WorldClass( $tournament, $ring ); 
			if( $request->{ type } eq 'ring' ) {
				$staging = new FreeScore::Forms::WorldClass( $tournament, 'staging' );
				push @{$progress->{ divisions }}, @{$staging->{ divisions }};
			}
		} catch { $c->{ device }->send( { json => { error => "Error reading database '$tournament', ring $ring: $_" }}); };

		# ===== IDENTIFY WHICH CLIENTS ARE JUDGES
		$c->{ judge } = $judge if defined $judge;
		print STDERR "JUDGE $judge: " if defined $judge;

		# ===== WATCH FILESYSTEM FOR CHANGES
		$manager->watch_files( $judge );

		# ===== HANDLE REQUEST
		my $clients = $client->{ $group };
		try   { $manager->handle( $request, $progress, $clients ); }
		catch { $c->{ device }->send( { json => { error => "Error while processing request: $_\n", request => $request }}); };
	});

	# ----------------------------------------
	# Handle disconnects
	# ----------------------------------------
	$self->on( finish => sub { delete $client->{ $group }{ $id }; });
};

# ============================================================
# ERROR TRAPPING
# ============================================================
any '*command' => sub {
	my $self = shift;
	my $command = $self->param( 'command' );
	$self->res->headers->header( 'Access-Control-Allow-Origin' => 'http://freescore.net' );
	$self->render( json => { error => "Worldclass Service Error: Unknown command: $command" });
};

# ============================================================
# HELPER FUNCTIONS
# ============================================================

# ============================================================
sub autopilot {
# ============================================================
#** @method( division, judge )
#   @brief Automatically advances to the next form/athlete/round/division
#   Called when judges finish scoring an athlete's form 
#*
	my $division = shift;
	my $judge    = shift;

	# ===== DISALLOW REDUNDANT AUTOPILOT REQUESTS
	if( my $locked = $division->autopilot() ) {
		return { warning => 'Autopilot is already engaged for this ring by ' . ($locked == 1 ? 'Referee' : 'Judge ' . ($locked - 1)) . '.' };
	}

	# ===== ENGAGE AUTOPILOT
		$division->autopilot( 'on' );
		$division->write();
	} catch {
		return { error => $_ };
	};

	my $delay = { leaderboard => 9, next => 6, total => 0 };
	my $round = $division->{ round };
	my $order = $division->{ order }{ $round };
	my $forms = $division->{ forms }{ $round };
	my $j     = first_index { $_ == $division->{ current } } @$order;

	my $last = {
		athlete => ($division->{ current } == $order->[ -1 ]),
		form    => ($division->{ form }    == int( @$forms ) - 1),
		round   => ($division->{ round } eq 'finals' || $division->{ round } eq 'ro2'),
		each2   => (!($j % 2)),
	};

	# ===== AUTOPILOT ACTIONS
	my $action = { show => {}, go => {} };
	# ----------------------------------------
	$action->{ show }{ leaderboard } = sub {
	# ----------------------------------------
		return unless $division->autopilot(); # Cancel request if autopilot is disengaged
		if( $last->{ form } && ( $last->{ each2 } || $last->{ athlete } )) { 
			$division->display() unless $division->is_display(); 
			$division->write(); 
			Mojo::IOLoop->timer( $delay->{ next } => $action->{ go }{ next } );
			$delay->{ total } += $delay->{ next };

		} else {
			$action->{ go }{ next }();
		}
	};
	# ----------------------------------------
	$action->{ go }{ next } = sub {
	# ----------------------------------------
		return unless $division->autopilot(); # Cancel request if autopilot is disengaged
		my $go_next = {
			round   => $last->{ form } &&   $last->{ athlete } && ! $last->{ round },
			athlete => $last->{ form } && ! $last->{ athlete },
			form    => ! $last->{ form }
		};

		if    ( $go_next->{ round }   ) { $division->next_round(); }
		elsif ( $go_next->{ athlete } ) { $division->next_available_athlete(); }
		elsif ( $go_next->{ form }    ) { $division->next_form(); }
		$division->autopilot( 'off' ); # Finished. Disengage autopilot for now.
		$division->write();
	};

	# ===== AUTOPILOT BEHAVIOR
	# Autopilot behavior comprises the two afforementioned actions in
	# serial, with delays between.
	try {
		$delay->{ total } += $delay->{ leaderboard };
		Mojo::IOLoop->timer( $delay->{ leaderboard } => $action->{ show }{ leaderboard } );
		return { description => 'Autopilot is engaged', delay => $delay->{ total } };
	} catch {
		return { error => $_ };
	};
};

# ============================================================
# HYPNOTOAD SERVER
# ============================================================
mkdir '/var/log/freescore' unless -e '/var/log/freescore';
app->config( hypnotoad => { listen => [ 'http://*:3088' ], pid_file => '/var/run/worldclass.pid', workers => 1 });
app->log( new Mojo::Log( path => '/var/log/freescore/worldclass.log', level => 'debug' ));
app->start();
